/**
 * AUTO-GENERATED FILE
 * This file is automatically generated. Do not edit it directly.
 * Instead, run `yarn generate-error-classes` after editing `/source-generators/http-errors/errors.yaml`.
 */

import { HttpError } from "./HttpError";

/**
 * HTTP 400: Bad Request
 * @description The server cannot or will not process the request due to an apparent client error (e.g., malformed request syntax, size too large, invalid request message framing, or deceptive request routing).
 * @name Bad Request
 */
export class HttpBadRequestError extends HttpError {
    constructor(m: string = 'Bad Request') {
        super(m, 400, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpBadRequestError.prototype);
    }
}

/**
 * HTTP 401: Unauthorized
 * @description Similar to 403 Forbidden, but specifically for use when authentication is required and has failed or has not yet been provided. The response must include a WWW-Authenticate header field containing a challenge applicable to the requested resource.
 * @name Unauthorized
 * @see https://tools.ietf.org/html/rfc7235
 */
export class HttpUnauthorizedError extends HttpError {
    constructor(m: string = 'Unauthorized') {
        super(m, 401, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpUnauthorizedError.prototype);
    }
}

/**
 * HTTP 402: Payment Required
 * @description Reserved for future use
 * @name Payment Required
 */
export class HttpPaymentRequiredError extends HttpError {
    constructor(m: string = 'Payment Required') {
        super(m, 402, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpPaymentRequiredError.prototype);
    }
}

/**
 * HTTP 403: Forbidden
 * @description The request contained valid data and was understood by the server, but the server is refusing action. This may be due to the user not having the necessary permissions for a resource or needing an account of some sort, or attempting a prohibited action (e.g. creating a duplicate record where only one is allowed). This code is also typically used if the request provided authentication via the WWW-Authenticate header field, but the server did not accept that authentication. The request should not be repeated.
 * @name Forbidden
 */
export class HttpForbiddenError extends HttpError {
    constructor(m: string = 'Forbidden') {
        super(m, 403, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpForbiddenError.prototype);
    }
}

/**
 * HTTP 404: Not Found
 * @description The requested resource could not be found but may be available in the future. Subsequent requests by the client are permissible.
 * @name Not Found
 */
export class HttpNotFoundError extends HttpError {
    constructor(m: string = 'Not Found') {
        super(m, 404, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpNotFoundError.prototype);
    }
}

/**
 * HTTP 405: Method Not Allowed
 * @description A request method is not supported for the requested resource; for example, a GET request on a form that requires data to be presented via POST, or a PUT request on a read-only resource.
 * @name Method Not Allowed
 */
export class HttpMethodNotAllowedError extends HttpError {
    constructor(m: string = 'Method Not Allowed') {
        super(m, 405, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpMethodNotAllowedError.prototype);
    }
}

/**
 * HTTP 406: Not Acceptable
 * @description The requested resource is capable of generating only content not acceptable according to the Accept headers sent in the request
 * @name Not Acceptable
 */
export class HttpNotAcceptableError extends HttpError {
    constructor(m: string = 'Not Acceptable') {
        super(m, 406, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpNotAcceptableError.prototype);
    }
}

/**
 * HTTP 407: Proxy Authentication Required
 * @description The client must first authenticate itself with the proxy.
 * @name Proxy Authentication Required
 * @see https://tools.ietf.org/html/rfc7235
 */
export class HttpProxyAuthenticationRequiredError extends HttpError {
    constructor(m: string = 'Proxy Authentication Required') {
        super(m, 407, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpProxyAuthenticationRequiredError.prototype);
    }
}

/**
 * HTTP 408: Request Timeout
 * @description The server timed out waiting for the request. According to HTTP specifications: 'The client did not produce a request within the time that the server was prepared to wait. The client MAY repeat the request without modifications at any later time.'
 * @name Request Timeout
 */
export class HttpRequestTimeoutError extends HttpError {
    constructor(m: string = 'Request Timeout') {
        super(m, 408, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpRequestTimeoutError.prototype);
    }
}

/**
 * HTTP 409: Conflict
 * @description Indicates that the request could not be processed because of conflict in the current state of the resource, such as an edit conflict between multiple simultaneous updates.
 * @name Conflict
 */
export class HttpConflictError extends HttpError {
    constructor(m: string = 'Conflict') {
        super(m, 409, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpConflictError.prototype);
    }
}

/**
 * HTTP 410: Gone
 * @description Indicates that the resource requested is no longer available and will not be available again. This should be used when a resource has been intentionally removed and the resource should be purged. Upon receiving a 410 status code, the client should not request the resource in the future.
 * @name Gone
 */
export class HttpGoneError extends HttpError {
    constructor(m: string = 'Gone') {
        super(m, 410, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpGoneError.prototype);
    }
}

/**
 * HTTP 411: Length Required
 * @description The request did not specify the length of its content, which is required by the requested resource.
 * @name Length Required
 */
export class HttpLengthRequiredError extends HttpError {
    constructor(m: string = 'Length Required') {
        super(m, 411, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpLengthRequiredError.prototype);
    }
}

/**
 * HTTP 412: Precondition Failed
 * @description The server does not meet one of the preconditions that the requester put on the request header fields
 * @name Precondition Failed
 * @see https://tools.ietf.org/html/rfc7232
 */
export class HttpPreconditionFailedError extends HttpError {
    constructor(m: string = 'Precondition Failed') {
        super(m, 412, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpPreconditionFailedError.prototype);
    }
}

/**
 * HTTP 413: Request Entity Too Large
 * @description The request is larger than the server is willing or able to process. Previously called "Request Entity Too Large"
 * @name Request Entity Too Large
 * @see https://tools.ietf.org/html/rfc7231
 */
export class HttpRequestEntityTooLargeError extends HttpError {
    constructor(m: string = 'Request Entity Too Large') {
        super(m, 413, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpRequestEntityTooLargeError.prototype);
    }
}

/**
 * HTTP 414: Request-URI Too Long
 * @description The URI provided was too long for the server to process.
 * @name Request-URI Too Long
 * @see https://tools.ietf.org/html/rfc7231
 */
export class HttpRequestURITooLongError extends HttpError {
    constructor(m: string = 'Request-URI Too Long') {
        super(m, 414, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpRequestURITooLongError.prototype);
    }
}

/**
 * HTTP 415: Unsupported Media Type
 * @description The request entity has a media type which the server or resource does not support.
 * @name Unsupported Media Type
 * @see https://tools.ietf.org/html/rfc7231
 */
export class HttpUnsupportedMediaTypeError extends HttpError {
    constructor(m: string = 'Unsupported Media Type') {
        super(m, 415, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpUnsupportedMediaTypeError.prototype);
    }
}

/**
 * HTTP 416: Requested Range Not Satisfiable
 * @description The client has asked for a portion of the file (byte serving), but the server cannot supply that portion
 * @name Requested Range Not Satisfiable
 * @see https://tools.ietf.org/html/rfc7233
 */
export class HttpRequestedRangeNotSatisfiableError extends HttpError {
    constructor(m: string = 'Requested Range Not Satisfiable') {
        super(m, 416, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpRequestedRangeNotSatisfiableError.prototype);
    }
}

/**
 * HTTP 417: Expectation Failed
 * @description The server cannot meet the requirements of the Expect request-header field.
 * @name Expectation Failed
 */
export class HttpExpectationFailedError extends HttpError {
    constructor(m: string = 'Expectation Failed') {
        super(m, 417, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpExpectationFailedError.prototype);
    }
}

/**
 * HTTP 418: I'm A Teapot
 * @description Indicates that the server cannot brew coffee, because it is a teapot.
 * @name I'm A Teapot
 * @see https://tools.ietf.org/html/rfc2324
 */
export class HttpImATeapotError extends HttpError {
    constructor(m: string = 'I\'m A Teapot') {
        super(m, 418, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpImATeapotError.prototype);
    }
}

/**
 * HTTP 421: Misdirected Request
 * @description The request was directed at a server that is not able to produce a response
 * @name Misdirected Request
 * @see https://tools.ietf.org/html/rfc7540
 */
export class HttpMisdirectedRequestError extends HttpError {
    constructor(m: string = 'Misdirected Request') {
        super(m, 421, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpMisdirectedRequestError.prototype);
    }
}

/**
 * HTTP 425: Too Early
 * @description Indicates that the server is unwilling to risk processing a request that might be replayed.
 * @name Too Early
 * @see https://tools.ietf.org/html/rfc8470
 */
export class HttpTooEarlyError extends HttpError {
    constructor(m: string = 'Too Early') {
        super(m, 425, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpTooEarlyError.prototype);
    }
}

/**
 * HTTP 426: Upgrade Required
 * @description The client should switch to a different protocol such as TLS/1.0, given in the Upgrade header field.
 * @name Upgrade Required
 */
export class HttpUpgradeRequiredError extends HttpError {
    constructor(m: string = 'Upgrade Required') {
        super(m, 426, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpUpgradeRequiredError.prototype);
    }
}

/**
 * HTTP 428: Precondition Required
 * @description The origin server requires the request to be conditional. Intended to prevent the 'lost update' problem, where a client GETs a resource's state, modifies it, and PUTs it back to the server, when meanwhile a third party has modified the state on the server, leading to a conflict.
 * @name Precondition Required
 * @see https://tools.ietf.org/html/rfc6585
 */
export class HttpPreconditionRequiredError extends HttpError {
    constructor(m: string = 'Precondition Required') {
        super(m, 428, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpPreconditionRequiredError.prototype);
    }
}

/**
 * HTTP 429: Too Many Requests
 * @description The user has sent too many requests in a given amount of time. Intended for use with rate-limiting schemes.
 * @name Too Many Requests
 * @see https://tools.ietf.org/html/rfc6585
 */
export class HttpTooManyRequestsError extends HttpError {
    constructor(m: string = 'Too Many Requests') {
        super(m, 429, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpTooManyRequestsError.prototype);
    }
}

/**
 * HTTP 431: Request Header Fields Too Large
 * @description The server is unwilling to process the request because either an individual header field, or all the header fields collectively, are too large.
 * @name Request Header Fields Too Large
 * @see https://tools.ietf.org/html/rfc6585
 */
export class HttpRequestHeaderFieldsTooLargeError extends HttpError {
    constructor(m: string = 'Request Header Fields Too Large') {
        super(m, 431, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpRequestHeaderFieldsTooLargeError.prototype);
    }
}

/**
 * HTTP 451: Unavailable For Legal Reasons
 * @description A server operator has received a legal demand to deny access to a resource or to a set of resources that includes the requested resource.
 * @name Unavailable For Legal Reasons
 * @see https://tools.ietf.org/html/rfc7725
 */
export class HttpUnavailableForLegalReasonsError extends HttpError {
    constructor(m: string = 'Unavailable For Legal Reasons') {
        super(m, 451, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpUnavailableForLegalReasonsError.prototype);
    }
}

/**
 * HTTP 500: Internal Server Error
 * @description A generic error message, given when an unexpected condition was encountered and no more specific message is suitable
 * @name Internal Server Error
 */
export class HttpInternalServerErrorError extends HttpError {
    constructor(m: string = 'Internal Server Error') {
        super(m, 500, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpInternalServerErrorError.prototype);
    }
}

/**
 * HTTP 501: Not Implemented
 * @description The server either does not recognize the request method, or it lacks the ability to fulfil the request
 * @name Not Implemented
 */
export class HttpNotImplementedError extends HttpError {
    constructor(m: string = 'Not Implemented') {
        super(m, 501, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpNotImplementedError.prototype);
    }
}

/**
 * HTTP 502: Bad Gateway
 * @description The server was acting as a gateway or proxy and received an invalid response from the upstream server
 * @name Bad Gateway
 */
export class HttpBadGatewayError extends HttpError {
    constructor(m: string = 'Bad Gateway') {
        super(m, 502, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpBadGatewayError.prototype);
    }
}

/**
 * HTTP 503: Service Unavailable
 * @description The server cannot handle the request (because it is overloaded or down for maintenance)
 * @name Service Unavailable
 */
export class HttpServiceUnavailableError extends HttpError {
    constructor(m: string = 'Service Unavailable') {
        super(m, 503, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpServiceUnavailableError.prototype);
    }
}

/**
 * HTTP 504: Gateway Timeout
 * @description The server was acting as a gateway or proxy and did not receive a timely response from the upstream server
 * @name Gateway Timeout
 */
export class HttpGatewayTimeoutError extends HttpError {
    constructor(m: string = 'Gateway Timeout') {
        super(m, 504, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpGatewayTimeoutError.prototype);
    }
}

/**
 * HTTP 505: HTTP Version Not Supported
 * @description The server does not support the HTTP protocol version used in the request
 * @name HTTP Version Not Supported
 */
export class HttpVersionNotSupportedError extends HttpError {
    constructor(m: string = 'HTTP Version Not Supported') {
        super(m, 505, {});

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, HttpVersionNotSupportedError.prototype);
    }
}

